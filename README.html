<HTML>
<HEAD>
<TITLE>DNS::ZoneParse - Perl extension for parsing and manipulating DNS Zone Files.</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#installation">INSTALLATION</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<UL>

		<LI><A HREF="#methods">METHODS</A></LI>
		<LI><A HREF="#examples">EXAMPLES</A></LI>
	</UL>

	<LI><A HREF="#export">EXPORT</A></LI>
	<LI><A HREF="#to do">TO DO</A></LI>
	<LI><A HREF="#bugs & requests">BUGS &amp; REQUESTS</A></LI>
	<LI><A HREF="#author">AUTHOR</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>DNS::ZoneParse - Perl extension for parsing and manipulating DNS Zone Files.</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
        use DNS::ZoneParse;</PRE>
<PRE>
        my $dnsfile = DNS::ZoneParse-&gt;new();</PRE>
<PRE>
        $dnsfile-&gt;Prepare(&quot;/path/to/dns/zonefile.db&quot;);</PRE>
<PRE>
        print $dnsfile-&gt;{Zone}-&gt;{SOA}-&gt;{serial};
        $dnsfile-&gt;newSerial();
        print $dnsfile-&gt;{Zone}-&gt;{SOA}-&gt;{serial};
</PRE>
<PRE>

        print $dnsfile-&gt;PrintZone();</PRE>
<P>
<HR>
<H1><A NAME="installation">INSTALLATION</A></H1>
<PRE>
   perl Makefile.PL
   make
   make test
   make install</PRE>
<P>Win32 users substitute ``make'' with ``nmake'' or equivalent. 
nmake is available at <A HREF="http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/Nmake15.exe">http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/Nmake15.exe</A></P>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>This module will parse a Zone File and put all the Resource Records (RRs) into an anonymous hash structure. At the moment, the following types of RRs are supported: SOA, NS, MX, A, CNAME, TXT, PTR. It could be useful for maintaining DNS zones, or for transferring DNS zones to other servers. If you want to generate an XML-friendly version of your zone files, it is easy to use XML::Simple with this module once you have parsed the zonefile.</P>
<P>The Prepare method scans the DNS zonefile - removes comments and seperates the file into it's constituent records. It then parses each record and stores the objects in the $object-&gt;{Zone} hash. Using Data::Dumper on that object will give you a better idea of what this looks like than I can describe.</P>
<P>You can access the objects in the $object-&gt;{Zone} hash to add\remove\modify RRs directly, and then you can call $object-&gt;PrintZone(), and it will return and create a new Zone File in the $object-&gt;{ZoneFile} string.</P>
<P>I will update this documentation - it's pretty sparse at the moment, but many more features coming...</P>
<P>
<H2><A NAME="methods">METHODS</A></H2>
<DL>
<DT><STRONG><A NAME="item_new">new</A></STRONG><BR>
<DD>
This creates the DNS::ZoneParse Object
<P>Example:
    my $dnsfile = DNS::ZoneParse-&gt;new();</P>
<P></P>
<DT><STRONG><A NAME="item_Prepare">Prepare</A></STRONG><BR>
<DD>
<A HREF="#item_Prepare"><CODE>Prepare()</CODE></A> will do some preliminary checks and then parse the supplied DNS Zone File. You can pass it the text content from the DNS Zone File as a reference or the path to a filename.
<P>Examples:</P>
<PRE>
    $dnsfile-&gt;Prepare(&quot;/path/to/zonefile.db&quot;);</PRE>
<P>or</P>
<PRE>
    my $zonefile;
    open (Zone, &quot;/path/to/zonefile.db&quot;);
    while (&lt;Zone&gt;) { $zonefile .= $_ }
    close (Zone);</PRE>
<PRE>
    $dnsfile-&gt;Prepare(\$zonefile);</PRE>
<P></P>
<DT><STRONG><A NAME="item_Parse">Parse</A></STRONG><BR>
<DD>
<A HREF="#item_Parse"><CODE>Parse()</CODE></A> is called internally by the <A HREF="#item_Prepare"><CODE>Prepare()</CODE></A> method. You can call it independently. It takes no arguments. All that is required is that $object-&gt;{ZoneFile} (string) contains a valid DNS Zone File.
<P></P>
<DT><STRONG><A NAME="item_newSerial">newSerial</A></STRONG><BR>
<DD>
<A HREF="#item_newSerial"><CODE>newSerial()</CODE></A> incriments the Zone serial number. You can pass a positive number to add to the current serial number or it will default to 1.
<P>Examples:</P>
<PRE>
    $dnsfile-&gt;newSerial();    # adds 1 to the original serial number
    $dnsfile-&gt;newSerial(50);    # adds 50 to the original serial number
    $dnsfile-&gt;newSerial(-50);    # adds 1 to the original serial number</PRE>
<P></P>
<DT><STRONG><A NAME="item_PrintZone">PrintZone</A></STRONG><BR>
<DD>
<A HREF="#item_PrintZone"><CODE>PrintZone()</CODE></A> loops through the Resource Records and creates a zone file in $object-&gt;{ZoneFile}. It also returns the new zonefile.
<P></P></DL>
<P>
<H2><A NAME="examples">EXAMPLES</A></H2>
<P>This script will print the A records in a zone file, add a new A record for the name ``new'' and then return the zone file.</P>
<PRE>
    use strict;
    use DNS::ZoneParse;
</PRE>
<PRE>

    my $dnsfile = DNS::ZoneParse-&gt;new();
    $dnsfile-&gt;Prepare(&quot;/path/to/zonefile.db&quot;);</PRE>
<PRE>

    print &quot;Current A Records\n&quot;;
    foreach my $a (@{$dnsfile-&gt;{Zone}-&gt;{A}}) {
        print &quot;$a-&gt;{name} resolves at $a-&gt;{host}\n&quot;;
    }</PRE>
<PRE>
    push (@{$dnsfile-&gt;{Zone}-&gt;{A}}, { name =&gt; 'new', class =&gt; 'IN', host =&gt; '127.0.0.1', ttl =&gt; '' });</PRE>
<PRE>
    $dnsfile-&gt;newSerial();
    my $newfile = $dnsfile-&gt;PrintZone();</PRE>
<P>This script will convert a DNS Zonefile to an XML file using XML::Simple.</P>
<PRE>
    use strict;
    use DNS::ZoneParse;
    use XML::Simple;
</PRE>
<PRE>

    my $dnsfile = DNS::ZoneParse-&gt;new();
    $dnsfile-&gt;Prepare(&quot;/path/to/zonefile.db&quot;);</PRE>
<PRE>
    my $new_xml = XMLout($dnsfile-&gt;{Zone}, noattr =&gt; 1, suppressempty =&gt; 1, rootname =&gt; $dnsfile-&gt;{Zone}-&gt;{SOA}-&gt;{serial});</PRE>
<P>
<HR>
<H1><A NAME="export">EXPORT</A></H1>
<P>None by default. Object-oriented interface.</P>
<P>
<HR>
<H1><A NAME="to do">TO DO</A></H1>
<P>These are things that I need to do...</P>
<DL>
<DT><STRONG><A NAME="item_IPv6_compatability">IPv6 compatability</A></STRONG><BR>
<DD>
There is already space for the AAAA records, but I need to read the rest of the RFCs before I finish this part.
<P></P>
<DT><STRONG><A NAME="item_More_intelligent_serial_number_generation%2E">More intelligent serial number generation.</A></STRONG><BR>
<DD>
Possibly add the option of date-based updates to serial number
<P></P>
<DT><STRONG><A NAME="item_Cleaner_parsing">Cleaner parsing</A></STRONG><BR>
<DD>
The parsing here does work on the tested systems, but there may be cleaner ways of doing it.
<P></P>
<DT><STRONG><A NAME="item_Better_documentation">Better documentation</A></STRONG><BR>
<DD>
Come on, you know this is hopeless!
<P></P></DL>
<P>
<HR>
<H1><A NAME="bugs & requests">BUGS &amp; REQUESTS</A></H1>
<P>Please let me know!</P>
<P>
<HR>
<H1><A NAME="author">AUTHOR</A></H1>
<P>S. Flack : <A HREF="mailto:perl@simonflack.com">perl@simonflack.com</A></P>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P>DNS::ZoneFile</P>

</BODY>

</HTML>
